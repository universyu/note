### 泛型函数

用 T 表征实际运行期间的类型

```ts
function func<T>(arr:T[]) : T | undefined{
	return arr[0]
}
```

泛型函数约束，使用 extends 让不符合条件的参数直接报错

```typescript
function func<T extends { length: number }>(arr:T){
	console.log(arr)
}
```

返回值统一性原则：用泛型表征的类型必须有统一性

```typescript
function minimumLength<Type extends { length: number }>(
obj: Type,
minimum: number
): Type {
if (obj.length >= minimum) {
return obj;
} else {
return { length: minimum };
Type '{ length: number; }' is not assignable to type 'Type'. '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.
}
}
```

泛型失效问题：如果手动给泛型加上 extends any 的限制就会导致后面用这个 T 返回的时候还是会被校验成 any 不会是实时计算的



