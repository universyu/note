# javaScript

### 执行上下文

执行上下文以函数为单位，放在调用栈之中。其中的变量环境以函数为单位，其中的词法环境以块为单位，还有依照作用域链生成的对外部执行上下文的引用，还有this

#### 变量提升

声明会被提升，而赋值不会，下面有两种定义函数的方式，只有第一种可以在定义之前使用

```js
function foo(){
    ...
}
    
var bar = function(){
    ...
}
```

在编译阶段会把带有var声明的语句提出来，把声明的变量放到执行上下文的变量环境中，如果有多个，会保留最后一个，编译时只是会给变量留个位置，赋值语句要到执行阶段才会执行，另外，变量环境存储的是在当下这个函数体内部声明的变量

#### 词法环境

用let或者const定义的变量，会在编译阶段放入执行上下文的词法环境中，按照块级作用域来存放，词法环境中也是栈结构

#### 词法作用域

由函数声明的位置决定，是静态作用域

#### 作用域链

变量环境中存了一个外部执行上下文的引用，作用域链由词法作用域决定

#### 闭包

由作用域链的特性，如果在一个函数内部有函数，那么内部的函数可以访问到外部函数的变量，即便外部函数已经调用结束。函数被内部函数保留引用的变量的集合称为此函数的闭包。JavaScript引擎会扫描内部函数判断是否产生闭包，如果产生就会构造出一个对象来保留变量，这个对象被内部函数引用

#### 变量查找顺序

先在词法环境中由栈顶找到栈底，然后在变量环境中查找，再顺着作用域链找其他执行上下文

#### this

this和执行上下文绑定

- 函数在全局调用则this为全局对象

```js
var myObj = {
  showThis: function(){
    console.log(this)
  }
}
var foo = myObj.showThis
foo()
```

- 函数作为对象的成员被调用则this指向这个对象

上面的代码改成直接调用`myObj.showThis()`则this为myObj



- 构造函数的this

```js
function CreateObj(){
  this.name = "myObj"
}
var myObj = new CreateObj()
```

相当于先创建一个空对象，然后用call调用CreateObj



- 箭头函数的this

嵌套函数的内层函数不会继承外层函数的this，但是箭头函数会



### 内存

#### 对象

一般类型的变量直接存在栈中，而对象则存在堆中，变量只保留其引用

#### 垃圾回收

堆中的数据分为新生区和老生区，前者负责存放生命周期短的对象，而后者存放生命周期长的对象，分别使用副垃圾回收器和主垃圾回收器

##### 副垃圾回收器

将新生区分为两个区域，`对象区`和`空闲区`，对象区要满时，取其中有效的数据复制到空闲区，并将两者交换，因为复制消耗大，新生区比较小，由于空间小，所以两次垃圾回收都没清楚的数据会被放入老生区

##### 主垃圾回收器

标记-清除或者标记-清理

##### 增量标记

为了降低老生区带来的停顿感，将标记分为多个子任务，和js代码交替执行



### 运行过程

#### 1、词法、语法分析

词法分析生成`AST`，语法分析生成执行上下文

#### 2、生成字节码

解释器根据AST得到字节码

#### 3、执行代码

解释器直接执行字节码，如果一段代码需要多次执行，就由编译器得到机器码，这种技术称为即时编译（JIT）



