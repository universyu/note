
## 依赖存储结构

需要有一个 weakmap 存储每个对象对应需要重新执行的函数，map 的键是对象，值是 map ，这个 map 存储对象每个 key 对应需要重新执行的函数，这个 map 的值是一个 set ，派发更新就是把整个 set 里面的所有函数都执行一遍

## 激活函数并清理消除的函数

用全局变量 `activeEffect` 控制当下激活的函数，依赖收集时把用到了当下激活函数的 set 都 push 到激活函数的 deps 中，每次派发更新执行函数前，先把这个函数从所有 set 中删除，然后把这个函数设置为激活函数，然后再执行这个函数

```js
function cleanup(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}

function effect(fn) {
  const effectFn = () => {
    cleanup(effectFn)
    activeEffect = effectFn;
    fn();
  }
  effectFn.deps = [];
  effectFn();
}
```


## 派发更新防止死循环

有可能在派发更新时触发了 state 的更新，于是会修改待触发函数列表，如果派发更新直接遍历执行这个列表，可能导致死循环，所以需要开一个新的 set 在派发更新执行之前就把实际需要遍历的列表存储下来。又由于流程上是先把函数设置为 `activeEffect` 然后再执行它，如果在执行过程中改动了 state 就会触发派发更新，如果在这之前这个函数已经在待触发列表里面了，那么也会导致死循环，所以还需要把当下的 `activeEffect` 从列表中去掉
