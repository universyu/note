
## 依赖存储结构

需要有一个 weakmap 存储每个对象对应需要重新执行的函数，map 的键是对象，值是 map ，这个 map 存储对象每个 key 对应需要重新执行的函数，这个 map 的值是一个 set ，派发更新就是把整个 set 里面的所有函数都执行一遍

## 激活函数并清理消除的函数

用全局变量 `activeEffect` 控制当下激活的函数，依赖收集时把用到了当下激活函数的 set 都 push 到激活函数的 deps 中，每次派发更新执行函数前，先把这个函数从所有 set 中删除，然后把这个函数设置为激活函数，然后再执行这个函数

```js
function cleanup(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}

function effect(fn) {
  const effectFn = () => {
    cleanup(effectFn)
    activeEffect = effectFn;
    fn();
  }
  effectFn.deps = [];
  effectFn();
}
```

