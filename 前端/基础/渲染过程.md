# 渲染过程

## CSSOM

根节点是一个列表，它存储了所有`css`表，包括内部、外部、内联、浏览器默认表，表下是规则对象，规则对象由选择器和样式组成，样式里面是键值对，表示`css`样式。

## 文档解析

渲染主线程把字符串解析成`DOM`和`CSSOM`，用预解析线程预先下载外部的`CSS`和`js`。

主线程一路向下，遇到`CSS`未下载好不会等待，其下载和解析再预解析线程中进行，但是遇到`js`没下载好是会阻塞`html`的解析的，必须执行完了才向下。

## 样式计算

 通过 `css` 计算最终样式 `computed style`

## 布局计算

布局树中对象是`c++`对象，不可被`js`访问。只包含有几何信息的对象，`display: none`的不显示，在`DOM`树中不存在的伪元素（before、after等）会出现在布局树中，在布局树中，内容必须放在行盒中，行盒和块盒不可以相邻，`p`标签对应的是块盒



## 分层

分层方式由浏览器决定，可以用`css`属性`will-change`告诉浏览器哪些属性会变，从而影响决策



## 绘制

为每个分层生成绘制指令集，渲染主线程的工作结束，剩余工作转交其他线程。



## 分块

渲染进程的合成线程接收绘制指令，启动多个线程将每层分块，分块是为了优先画靠近屏幕可视区域的块



## 光栅化

GPU 进程把每个块变成位图，即获取每个块中所有像素点的颜色



## Draw

合成线程生成 `quad` 信息标识每个位图的位置，并考虑旋转、缩放等变换， `transform` 就是在这里做的， 与渲染主线程无关，所以高效，把 `quad` 交给 GPU 进程后由其产生系统调用，完成屏幕成像



## reflow

改动 `DOM` 或 `CSSOM` 时会导致布局树重算，性能开销比较大，如果 `js` 中触发 `reflow` ， 会等到其它代码执行后产生一个任务进消息队列，故 `reflow` 是异步的，但如果读取几何信息，可以强制同步 `reflow`



## repaint

没有改动几何信息，只改动了如颜色等可见信息，则只需要重新绘制，效率比 `reflow` 高
